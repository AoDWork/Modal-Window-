/* 
+++ ВИДЕО 1

Сделаем плагин для показа динамического модального окна. Так как делаться он будет без дополнительных библиотек,
    то сделаем подобие своей библиотеки JQuery. Разделим код на несколько файло для того что бы не смешивать код
    плагина, приложения и использования плагина.


Создаем файл base.js в нем по аналогии с библиотекой JQuery создаем главный объект библиотеки с символом доллара,
    const $ = {}

    в нашем случае это будет просто объект - база, к которой в последствии будем подключать плагины которые
    создадим.


Теперь в хтмл файле подключим base.js первым файлом скрипта перед закрывающим тегом /body.


Создаем файл index.js в нем будем вести собственно разработку, этот файл будет отвечать за само приложение, поэтому
    его мы подключим к хтмл последним. Между этими файлами будем подключать дополнительные плагины которые будем
    создавать. Их мы отделим в папку plugins.


Создаем modal.js - плагин для модального окна в папке plugins и подключаем его в хтмл между base.js и index.js.
    Подключаем после base.js - для того что бы в modal.js был доступен объект доллара $, потому что он по умолчанию
    складывается в глобальный объект window(так как у нас нету модульности), можно указать это явно в base.js
    написав window.$ = $.



В modal.js к объекту $ добавим ф-ю modal.
    $.modal = function() {
        
    }


Продумаем какой ф-онал должна выполнять эта ф-я. Окно должно открываться и закрываться. Пока все, создадим верстку
    МО в ХТМЛ файле, что бы потом перенести генерацию этого шаблона в динамику. Создадим ксс файл для модального
    окна и подключим его в хтмл.


Создаем контейнер с классом wmodal - что бы если подключен bootstrap этот класс не пересекался с классом modal из
    него. Добавим элементы:

    1) фон - эл. для затемнения всего остального контента(можно и без него но сделаем с ним что бы показать разные типы
        анимаций для разных элементов) <div class="modal-overlay">
        Пропишем для него стили в ксс - топ, райт, лефт, бот - по нулям что бы он покрывал всю зону видимости.
        
        .modal-overlay {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            background: rgba(0, 0, 0, .5); - черный цвет с прозрачностью 50%
        }


    2) Создаем корневой эл. для самого окна <div class="modal-window">, прописываем временные стили, позже изменим
        для того что бы сделать анимацию. margin: 100px auto; - выравнивание по ценру по и 100пкс отступ сверху.
    
        .modal-window {
            width: 800px;
            border-radius: 5px;
            background: white;
            margin: 100px auto;
            height: 500px;
        }

     Создаем 3 элемента для разных секций модального окна 
    

    3) <div class="modal-header"></div> Тут добавим тайтл <span class="modal-title">Темна бірюза</span> и кнопку 
        закрытия(крестик) <span data-close class="modal-close">&times;</span>, задаем для них стили
        
        .modal-header {
            padding: 5px 10px;
            display: flex;
            justify-content: space-between;
            border-bottom: 1px solid #eee;  - граница внизу - линия.
        }
        Таким образом расположим содержимое хедера(тайтл и крестик) по бокам окна.             

        .modal-title {
            font-size: 1.5rem;
        }

        .modal-close {
            cursor: pointer;
        }

        Со стилями можно поиграться самому.


    4) <div class="modal-body"></div> - тут будет основной контент, добавим картинку 
            <img class="modal-body__img" src="...  и параграф с текстом <p>. Удалим в .modal-window свойство 
             height: 500px; - теперь МО будет растягиваться по контенту. Добавим стили

        .modal-body {
            padding: 10px;
        }


    5) <div class="modal-footer"></div> - тут у нас будут кнопки, добавим их <button>Ok</button>
            <button>Cancel</button>
        
        .modal-footer {
            padding: 5px 10px;
            border-top: 1px solid #eee; - граница сверху
        }



Базовая верстка закончена. Переходим к JS.

В файле index.js пропишем создание плагина $.modal(); - обращаемся к условной библиотеке(объекту), вызываем
        ф-ю modal. Теперь мы хотим как то настроить МО и получить его рабочее состояние.

Так сейчас выглядит наша ф-я в modal, допишем ее
    
    $.modal = function() {
        
    }

    Будем получать объект с опциями - он будет настраивать будущее МО. Когда вызовем данный плагин мы хотим получить
        инстанс(экземпляр) этого МО с которым мы можем делать определенные операции(закрыть, открыть, изменять
        контент, уничтожать МО чтобы оно больше не существовало).
    
    Эта ф-я должна вернуть методы через которые мы будем взаимодействовать с инстансом.
        $.modal = function(options) {
            return {
                open(){},
                close() {}
            }
        }

    Для начала создадим методы open, close. Тогда они уже будут доступны в индексе
        const myModal = $.modal();
        myModal.open();

    *! Это не единственная реализация, их может быть много. Можно создавать МО через класс, но когда мы
        используем этот метод - мы пользуемся замыканием и поэтому нам доступны приватные переменные.
        Тут они могут быть ф-ями.

    Добавим еще один ключевой метод destroy() {} - он будет убирать созданный экземпляр МО, что бы оно
        не засоряло верстку и не заставляло сайт тормозить.


    Вернемся к реализации open, close - при создании таких плагинов хорошей практикой считается если визуал
        мы делаем в КСС, потому что показать плавно МО вместе с анимацией через JS нужно затратить намного
        больше сил(обращаться к интервалу, менять ДОМ дерево путем изменения стилей). Анимация на КСС написать
        гораздо проще. Эти два метода будут добавлять определенные классы к элементу, а дальше анимация будет
        переходить в КСС и выполняться там.


        Создадим приватную переменную(ф-ю) и назовем ее _createModal, она будет доступна только внутри ф-и
        Modal, поэтому мы нам не нужно ее экспортировать. (Пока вынесем ее за пределы ф-ии чтобы избежать
        нагрромождения кода в ф-и modal и так как она теперь отдельно то установка webpack решит эту проблему,
        я пока попробую ее не выносить что бы не лезть в webpack)
        
        !* нижнее подчеркивание _createModal перед именем
        ф-и означает что это системная(приватная) ф-я которая не должна быть вызвана отдельно.
        
        function _createModal(options) {

        }

        По сути создание МО - это создание шаблона окна которое мы заверстали. Мы вырежем верстку из ХТМЛ
        и можно было бы просто ее вернуть из этого метода, но для большего удобства(что бы в дальнейшем можно
        было взаимодействовать с инстансом МО) создадим переменную modal и в ней создаем div присваиваем ему класс
        wmodal и в него в позицию afterbegin вставляем верстку в обратных кавычках, удалив див с классом wmodal
        потому что мы его уже создали. Присоединяем нашу вестку к body. Дальше возвращаем этот инстанс modal.
        
        const modal = document.createElement('div'); - 
        modal.classList.add('wmodal'); - 
        modal.insertAdjacentHTML("afterbegin", ` 
            <div class="modal-overlay">
                <div class="modal-window">
                    <div class="modal-header">
                        <span class="modal-title">Темна бірюза</span>
                        <span data-close class="modal-close">&times;</span>
                    </div>
                    <div class="modal-body">
                        <img class="modal-body__img" src="./img/goods/female/t-shirt_blue.jpg" alt="Темна бірюза">
                        <p>Розмір 46-48 <br>Довжина виробу : 59 см  Колір : Темна бірюза  Колір яскравий,насичений.
                            Склад : 100% італійський котон
                            Добре пропускає повітря, дихає та добре вбирає вологу. Тому її цілком комфортно носити у спекотну пору року.
                            100 % італійський котон міцний,невибагливий у догляді,може використовуватися довгі роки.
                            Ручне прання при температурі не більше 30 градусів,сушити в горизонталі,щоб уникнути деформації виробу.</p>
                    </div>
                    <div class="modal-footer">
                        <button>Ok</button>
                        <button>Cancel</button>
                    </div>
                </div>
            </div>
        `)
        document.body.appendChild(modal);
        return modal


        В ф-и modal создаем переменную $modal и присваиваем результат работы _createModal(options); с опциями
        в которые пока ничего не передаем

        const $modal = _createModal(options);

        Теперь если на сайте в консоли мы пропишем $.modal(); появится МО. Нужно только предварительно
        закомментировать const myModal = $.modal(); - в index.js

        Этап создания МО выполнен.



Теперь сделаем так что бы МО появлялось только когда мы вызываем метод open и закрывалось вызовом метода close.
    В КСС вверху обратимся к .modal-window, .modal-overlay и пропишем видимость 0% и з индекс -1 это будут
    значения по умолчанию, таким образом мы скрыли эл. из видимости.

    .modal-window, .modal-overlay {
        opacity: 0;
        z-index: -1;
    }


    Что бы показать эл. пропишем что при наявности у wmodal класса open свойства эл. .modal-window, .modal-overlay
    будут следующими.

    .wmodal.open .modal-window, 
    .wmodal.open .modal-overlay {
        opacity: 1;
        z-index: 1001;
    }


    Теперь заполним метод open и close. В опен мы добавляем этот класс, в клосе удаляем.

        open(){
            $modal.classList.add('open'); 
        },
        close() {
            $modal.classList.remove('open'); 
        },


    В индекс пропишем просто модал вместо май модал и протестируем в консоли методами modal.open(); и 
    modal.close();

    const modal = $.modal();

    Работает, МО появляется и исчезает по командам.




Сделаем анимацию появления МО в КСС. Анимировать будем 2 эл. виндов и оверлей. У оверлея будем менять
    opacity, а окно будет появляться сверху как буд то бы выпрыгивая.


    Анимация виндоу. Для такой анимации самый простой способ поработать с transorm, изменим у modal-window
        margin: 100px auto;    на     margin: 0px auto;

        добавим позицию по умолчанию
        transform: translateY(-1000px); - позиция по оси У(вертикаль) -1000 пкс - вверху за экраном

        а когда окно будет видно с классом опен этот параметр изменится на 100пкс
        .wmodal.open .modal-window {
            transform: translateY(100px);
        }

        Но чтобы анимация была плавной в modal-window добавим
        transition: transform .5s ease-in; - анимировать transform за 0.5 секунды по ф-и ease-in


    Анимация оверлея. По умолчанию у него опасити 50%. Пропишем 0 - что бы он был не видим.
        background: rgba(0, 0, 0, .5); на background: rgba(0, 0, 0, 0);

        При видимости пропишем 50%
        .wmodal.open .modal-overlay {
            background: rgba(0, 0, 0, .5);
        }

        И добавим в modal-overlay
        transition: background .2s ease-in;
        !* при такой записи transition будет по всем 4м свойствам background image, color ...


С анимацией закрытия проблема, так как при удалении класса опен стили сразу сбрасываются на стандартные и
    мы не можем получить доступ к элементу. Поступим так, за время пока МО будет исчезать добавим к нему
    класс с анимацией и потом его удалим когда МО исчезнет из видимости. Пропишем это в методе close.

    Добавим в $.modal константу с количеством времени в милисекундах
    const ANIMATION_SPEED = 200;
    
    а в метод close добавим класс хайдинг и таймаут, по истечении которого этот класс будет удаляться из эл.
        close() {
            $modal.classList.remove('open'); 
            $modal.classList.add('hidding'); 
            setTimeout(() =>{
                $modal.classList.remove('hidding'); 
            }, ANIMATION_SPEED);
        },
    

    Пропишем класс hidding в ксс.

    Пока у эл. есть клас hidding они будут иметь такие свойства. 
    .wmodal.hidding .modal-window, 
    .wmodal.hidding .modal-overlay {
        opacity: 1;
        z-index: 1001;
    }

    К таким значениям они должны плавно прийти за время и по ф-и указанными в transition
    .wmodal.hidding .modal-window {
        transform: translateY(-1000px);
    }

    .wmodal.hidding .modal-overlay {
        background: rgba(0, 0, 0, 0);
    }

    Работает, теперь окно улетает вверх и края плавно светлеют.



Сделаем защиту от многократного клика, что бы не получилось что во время закрытия окна мы нажали на открытие
    и стили не наложились друг на друга. Создадим после const $modal = _createModal(options);
    переменную closing, которую будем менять во время закрытия. Сначала на тру а после удаления класса хайдинг
    на фолс. И добавис в опен условие что если closing не тру то тогда добавляем класс опен, иначе ничего не
    добавится. 
    !* При && - Если левый аргумент – false, оператор И возвращает его и заканчивает вычисления. Иначе – 
    вычисляет и возвращает правый аргумент.

    const $modal = _createModal(options);
    const ANIMATION_SPEED = 200;
    let closing = false;

    return {
        open(){
            !closing && $modal.classList.add('open'); 
        },
        close() {
            closing = true;
            $modal.classList.remove('open'); 
            $modal.classList.add('hidding'); 
            setTimeout(() =>{
                $modal.classList.remove('hidding'); 
                closing = false;
            }, ANIMATION_SPEED);
        },

Закончили первое видео. https://animate.style - библиотека с анимациями.




+++ ВИДЕО 2

Сделаем изменяемым тайтл, текст, размер и параметр closable(определяет может ли быть закрыто МО - показать ли крестик)
    через опции которые передаем.

    В индексе пропишем вместо const modal = $.modal(); объект внутри ф-ции с параметрами которые будут изменяться

        const modal = $.modal({
            title: 'Test Window',
            closable: true,
            content: `
            <h4>Modal is working</h4>
            <p>lorem  ipsum and so on</p>
            `,
            width: '400px'
        });

    
    Теперь нужно обработать переданные параметры. Все они храняться в modal.js в объекте options
        Начнем изменять например с контента. Удалим теги которые были в модал-бади и вставим 
        
        ${options.content || ''} - если его вдруг не будет, что бы не вывелся undefined ставим пустую строку ''


        Также поступаем и с тайтлом, но удаляем только текст тайтла, и вместо пустой строки при ошибке пишем
        текст по дефолту "Окно"

        <span class="modal-title">${options.title || "Окно"}</span>


        В тег модал-виндоу допишем стиль style="width: и значение из опшнс, но если его не будет тогда
        в начале этой ф-и создадим константу с дефолтным значением которое подставиться в случае ошибки

        const DEFAULT_WIDTH = "800px"

        <div class="modal-window" style="width: ${options.width || DEFAULT_WIDTH}">


        Теперь обработаем closable. Вырежем весь тег с крестиком и вместо него пропишем тернарный оператор.
        Если options.closable - тру, тогда будет показан крестик если фолс тогда пустая строка ''

        ${options.closable ? `<span class="modal-close">&times;</span>` : ''}


        Проверим результат через консоль. Все работает.




Закрытие окна по клику на крестик или на подложку(оверлей).

Сделаем это наиболее простым по мнению автора способом. Так как мы знаем что есть дата аттрибуты которые можно
    прописать в тегах для добавления кастомных аттрибутов тегу. Добавим аттрибут data-close всем эл. при клике
    на которые МО будет закрываться. В данном случае это крестик и модал оверлей. Присвоим ему значение "true"
    так как когда будем проверять на попадание по эл. у него в датасете клоуз должно быть тру, а если не
    присвоим будет пустая строка, что превратится в фолс, если при этом кликать на эл. который не содержит 
    аттрибут data-close то значение будет андефайнед.

    <div class="modal-overlay" data-close="true">

    ${options.closable ? `<span data-close="true" class="modal-close">&times;</span>` : ''}


    Навесим обработчик на весь элемент $modal в modal.js, а в ф-ю пропишем консольлог для просмотра по какому
    евент таргету клацаем есть ли у него в dataset(содержит все аттрибуты data у данного эл.) ключ close.
    Если нету - андефайнед, если есть - будет строка которую мы присвоили в data-close(в принципе не важно что
    за строка лишь бы не пустая)
    
    $modal.addEventListener('click', event => {
        console.log('Clicked', event.target.dataset.close)
    })

    То есть теперь можно прописать условие если event.target.dataset.close - тру, то вызвать метод close.
    Но этот метод идет позже по коду, как его вызвать, не дублировать же код. Возвращая методы опен и клоуз
    мы по сути возвращаем объект, поэтому ничего нам не мешает создать объект заранее(выше обработчика события)
    и перенести методы туда, а вернуть просто переменную с объектом.

        const $modal = _createModal(options);
        const ANIMATION_SPEED = 200;
        let closing = false;

        const modal = {
            open(){
                !closing && $modal.classList.add('open'); 
            },
            close() {
                closing = true;
                $modal.classList.remove('open'); 
                $modal.classList.add('hidding'); 
                setTimeout(() =>{
                    $modal.classList.remove('hidding'); 
                    closing = false;
                }, ANIMATION_SPEED);
            },
            destroy() {}
        }

        $modal.addEventListener('click', event => {
            console.log('Clicked', event.target.dataset.close);
            if(event.target.dataset.close){
                modal.close();
            }
        })

        return modal
    }

    Теперь при клике на крестик или подложку МО закрывается.