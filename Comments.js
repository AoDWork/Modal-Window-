/* 
+++ ВИДЕО 1

Сделаем плагин для показа динамического модального окна. Так как делаться он будет без дополнительных библиотек,
    то сделаем подобие своей библиотеки JQuery. Разделим код на несколько файло для того что бы не смешивать код
    плагина, приложения и использования плагина.


Создаем файл base.js в нем по аналогии с библиотекой JQuery создаем главный объект библиотеки с символом доллара,
    const $ = {}

    в нашем случае это будет просто объект - база, к которой в последствии будем подключать плагины которые
    создадим.


Теперь в хтмл файле подключим base.js первым файлом скрипта перед закрывающим тегом /body.


Создаем файл index.js в нем будем вести собственно разработку, этот файл будет отвечать за само приложение, поэтому
    его мы подключим к хтмл последним. Между этими файлами будем подключать дополнительные плагины которые будем
    создавать. Их мы отделим в папку plugins.


Создаем modal.js - плагин для модального окна в папке plugins и подключаем его в хтмл между base.js и index.js.
    Подключаем после base.js - для того что бы в modal.js был доступен объект доллара $, потому что он по умолчанию
    складывается в глобальный объект window(так как у нас нету модульности), можно указать это явно в base.js
    написав window.$ = $.



В modal.js к объекту $ добавим ф-ю modal.
    $.modal = function() {
        
    }


Продумаем какой ф-онал должна выполнять эта ф-я. Окно должно открываться и закрываться. Пока все, создадим верстку
    МО в ХТМЛ файле, что бы потом перенести генерацию этого шаблона в динамику. Создадим ксс файл для модального
    окна и подключим его в хтмл.


Создаем контейнер с классом wmodal - что бы если подключен bootstrap этот класс не пересекался с классом modal из
    него. Добавим элементы:

    1) фон - эл. для затемнения всего остального контента(можно и без него но сделаем с ним что бы показать разные типы
        анимаций для разных элементов) <div class="modal-overlay">
        Пропишем для него стили в ксс - топ, райт, лефт, бот - по нулям что бы он покрывал всю зону видимости.
        
        .modal-overlay {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            background: rgba(0, 0, 0, .5); - черный цвет с прозрачностью 50%
        }


    2) Создаем корневой эл. для самого окна <div class="modal-window">, прописываем временные стили, позже изменим
        для того что бы сделать анимацию. margin: 100px auto; - выравнивание по ценру по и 100пкс отступ сверху.
    
        .modal-window {
            width: 800px;
            border-radius: 5px;
            background: white;
            margin: 100px auto;
            height: 500px;
        }

     Создаем 3 элемента для разных секций модального окна 
    

    3) <div class="modal-header"></div> Тут добавим тайтл <span class="modal-title">Темна бірюза</span> и кнопку 
        закрытия(крестик) <span data-close class="modal-close">&times;</span>, задаем для них стили
        
        .modal-header {
            padding: 5px 10px;
            display: flex;
            justify-content: space-between;
            border-bottom: 1px solid #eee;  - граница внизу - линия.
        }
        Таким образом расположим содержимое хедера(тайтл и крестик) по бокам окна.             

        .modal-title {
            font-size: 1.5rem;
        }

        .modal-close {
            cursor: pointer;
        }

        Со стилями можно поиграться самому.


    4) <div class="modal-body"></div> - тут будет основной контент, добавим картинку 
            <img class="modal-body__img" src="...  и параграф с текстом <p>. Удалим в .modal-window свойство 
             height: 500px; - теперь МО будет растягиваться по контенту. Добавим стили

        .modal-body {
            padding: 10px;
        }


    5) <div class="modal-footer"></div> - тут у нас будут кнопки, добавим их <button>Ok</button>
            <button>Cancel</button>
        
        .modal-footer {
            padding: 5px 10px;
            border-top: 1px solid #eee; - граница сверху
        }



Базовая верстка закончена. Переходим к JS.

В файле index.js пропишем создание плагина $.modal(); - обращаемся к условной библиотеке(объекту), вызываем
        ф-ю modal. Теперь мы хотим как то настроить МО и получить его рабочее состояние.

Так сейчас выглядит наша ф-я в modal, допишем ее
    
    $.modal = function() {
        
    }

    Будем получать объект с опциями - он будет настраивать будущее МО. Когда вызовем данный плагин мы хотим получить
        инстанс(экземпляр) этого МО с которым мы можем делать определенные операции(закрыть, открыть, изменять
        контент, уничтожать МО чтобы оно больше не существовало).
    
    Эта ф-я должна вернуть методы через которые мы будем взаимодействовать с инстансом.
        $.modal = function(options) {
            return {
                open(){},
                close() {}
            }
        }

    Для начала создадим методы open, close. Тогда они уже будут доступны в индексе
        const myModal = $.modal();
        myModal.open();

    *! Это не единственная реализация, их может быть много. Можно создавать МО через класс, но когда мы
        используем этот метод - мы пользуемся замыканием и поэтому нам доступны приватные переменные.
        Тут они могут быть ф-ями.

    Добавим еще один ключевой метод destroy() {} - он будет убирать созданный экземпляр МО, что бы оно
        не засоряло верстку и не заставляло сайт тормозить.


    Вернемся к реализации open, close - при создании таких плагинов хорошей практикой считается если визуал
        мы делаем в КСС, потому что показать плавно МО вместе с анимацией через JS нужно затратить намного
        больше сил(обращаться к интервалу, менять ДОМ дерево путем изменения стилей). Анимация на КСС написать
        гораздо проще. Эти два метода будут добавлять определенные классы к элементу, а дальше анимация будет
        переходить в КСС и выполняться там.


        Создадим приватную переменную(ф-ю) и назовем ее _createModal, она будет доступна только внутри ф-и
        Modal, поэтому мы нам не нужно ее экспортировать. (Пока вынесем ее за пределы ф-ии чтобы избежать
        нагрромождения кода в ф-и modal и так как она теперь отдельно то установка webpack решит эту проблему,
        я пока попробую ее не выносить что бы не лезть в webpack)
        
        !* нижнее подчеркивание _createModal перед именем
        ф-и означает что это системная(приватная) ф-я которая не должна быть вызвана отдельно.
        
        function _createModal(options) {

        }

        По сути создание МО - это создание шаблона окна которое мы заверстали. Мы вырежем верстку из ХТМЛ
        и можно было бы просто ее вернуть из этого метода, но для большего удобства(что бы в дальнейшем можно
        было взаимодействовать с инстансом МО) создадим переменную modal и в ней создаем div присваиваем ему класс
        wmodal и в него в позицию afterbegin вставляем верстку в обратных кавычках, удалив див с классом wmodal
        потому что мы его уже создали. Присоединяем нашу вестку к body. Дальше возвращаем этот инстанс modal.
        
        const modal = document.createElement('div'); - 
        modal.classList.add('wmodal'); - 
        modal.insertAdjacentHTML("afterbegin", ` 
            <div class="modal-overlay">
                <div class="modal-window">
                    <div class="modal-header">
                        <span class="modal-title">Темна бірюза</span>
                        <span data-close class="modal-close">&times;</span>
                    </div>
                    <div class="modal-body">
                        <img class="modal-body__img" src="./img/goods/female/t-shirt_blue.jpg" alt="Темна бірюза">
                        <p>Розмір 46-48 <br>Довжина виробу : 59 см  Колір : Темна бірюза  Колір яскравий,насичений.
                            Склад : 100% італійський котон
                            Добре пропускає повітря, дихає та добре вбирає вологу. Тому її цілком комфортно носити у спекотну пору року.
                            100 % італійський котон міцний,невибагливий у догляді,може використовуватися довгі роки.
                            Ручне прання при температурі не більше 30 градусів,сушити в горизонталі,щоб уникнути деформації виробу.</p>
                    </div>
                    <div class="modal-footer">
                        <button>Ok</button>
                        <button>Cancel</button>
                    </div>
                </div>
            </div>
        `)
        document.body.appendChild(modal);
        return modal


        В ф-и modal создаем переменную $modal и присваиваем результат работы _createModal(options); с опциями
        в которые пока ничего не передаем

        const $modal = _createModal(options);

        Теперь если на сайте в консоли мы пропишем $.modal(); появится МО. Нужно только предварительно
        закомментировать const myModal = $.modal(); - в index.js

        Этап создания МО выполнен.



Теперь сделаем так что бы МО появлялось только когда мы вызываем метод open и закрывалось вызовом метода close.
    В КСС вверху обратимся к .modal-window, .modal-overlay и пропишем видимость 0% и з индекс -1 это будут
    значения по умолчанию, таким образом мы скрыли эл. из видимости.

    .modal-window, .modal-overlay {
        opacity: 0;
        z-index: -1;
    }


    Что бы показать эл. пропишем что при наявности у wmodal класса open свойства эл. .modal-window, .modal-overlay
    будут следующими.

    .wmodal.open .modal-window, 
    .wmodal.open .modal-overlay {
        opacity: 1;
        z-index: 1001;
    }


    Теперь заполним метод open и close. В опен мы добавляем этот класс, в клосе удаляем.

        open(){
            $modal.classList.add('open'); 
        },
        close() {
            $modal.classList.remove('open'); 
        },


    В индекс пропишем просто модал вместо май модал и протестируем в консоли методами modal.open(); и 
    modal.close();

    const modal = $.modal();

    Работает, МО появляется и исчезает по командам.




Сделаем анимацию появления МО в КСС. Анимировать будем 2 эл. виндов и оверлей. У оверлея будем менять
    opacity, а окно будет появляться сверху как буд то бы выпрыгивая.


    Анимация виндоу. Для такой анимации самый простой способ поработать с transorm, изменим у modal-window
        margin: 100px auto;    на     margin: 0px auto;

        добавим позицию по умолчанию
        transform: translateY(-1000px); - позиция по оси У(вертикаль) -1000 пкс - вверху за экраном

        а когда окно будет видно с классом опен этот параметр изменится на 100пкс
        .wmodal.open .modal-window {
            transform: translateY(100px);
        }

        Но чтобы анимация была плавной в modal-window добавим
        transition: transform .5s ease-in; - анимировать transform за 0.5 секунды по ф-и ease-in


    Анимация оверлея. По умолчанию у него опасити 50%. Пропишем 0 - что бы он был не видим.
        background: rgba(0, 0, 0, .5); на background: rgba(0, 0, 0, 0);

        При видимости пропишем 50%
        .wmodal.open .modal-overlay {
            background: rgba(0, 0, 0, .5);
        }

        И добавим в modal-overlay
        transition: background .2s ease-in;
        !* при такой записи transition будет по всем 4м свойствам background image, color ...


С анимацией закрытия проблема, так как при удалении класса опен стили сразу сбрасываются на стандартные и
    мы не можем получить доступ к элементу. Поступим так, за время пока МО будет исчезать добавим к нему
    класс с анимацией и потом его удалим когда МО исчезнет из видимости. Пропишем это в методе close.

    Добавим в $.modal константу с количеством времени в милисекундах
    const ANIMATION_SPEED = 200;
    
    а в метод close добавим класс хайдинг и таймаут, по истечении которого этот класс будет удаляться из эл.
        close() {
            $modal.classList.remove('open'); 
            $modal.classList.add('hidding'); 
            setTimeout(() =>{
                $modal.classList.remove('hidding'); 
            }, ANIMATION_SPEED);
        },
    

    Пропишем класс hidding в ксс.

    Пока у эл. есть клас hidding они будут иметь такие свойства. 
    .wmodal.hidding .modal-window, 
    .wmodal.hidding .modal-overlay {
        opacity: 1;
        z-index: 1001;
    }

    К таким значениям они должны плавно прийти за время и по ф-и указанными в transition
    .wmodal.hidding .modal-window {
        transform: translateY(-1000px);
    }

    .wmodal.hidding .modal-overlay {
        background: rgba(0, 0, 0, 0);
    }

    Работает, теперь окно улетает вверх и края плавно светлеют.



Сделаем защиту от многократного клика, что бы не получилось что во время закрытия окна мы нажали на открытие
    и стили не наложились друг на друга. Создадим после const $modal = _createModal(options);
    переменную closing, которую будем менять во время закрытия. Сначала на тру а после удаления класса хайдинг
    на фолс. И добавис в опен условие что если closing не тру то тогда добавляем класс опен, иначе ничего не
    добавится. 
    !* При && - Если левый аргумент – false, оператор И возвращает его и заканчивает вычисления. Иначе – 
    вычисляет и возвращает правый аргумент.

    const $modal = _createModal(options);
    const ANIMATION_SPEED = 200;
    let closing = false;

    return {
        open(){
            !closing && $modal.classList.add('open'); 
        },
        close() {
            closing = true;
            $modal.classList.remove('open'); 
            $modal.classList.add('hidding'); 
            setTimeout(() =>{
                $modal.classList.remove('hidding'); 
                closing = false;
            }, ANIMATION_SPEED);
        },

Закончили первое видео. https://animate.style - библиотека с анимациями.




+++ ВИДЕО 2

Сделаем изменяемым тайтл, текст, размер и параметр closable(определяет может ли быть закрыто МО - показать ли крестик)
    через опции которые передаем.

    В индексе пропишем вместо const modal = $.modal(); объект внутри ф-ции с параметрами которые будут изменяться

        const modal = $.modal({
            title: 'Test Window',
            closable: true,
            content: `
            <h4>Modal is working</h4>
            <p>lorem  ipsum and so on</p>
            `,
            width: '400px'
        });

    
    Теперь нужно обработать переданные параметры. Все они храняться в modal.js в объекте options
        Начнем изменять например с контента. Удалим теги которые были в модал-бади и вставим 
        
        ${options.content || ''} - если его вдруг не будет, что бы не вывелся undefined ставим пустую строку ''


        Также поступаем и с тайтлом, но удаляем только текст тайтла, и вместо пустой строки при ошибке пишем
        текст по дефолту "Окно"

        <span class="modal-title">${options.title || "Окно"}</span>


        В тег модал-виндоу допишем стиль style="width: и значение из опшнс, но если его не будет тогда
        в начале этой ф-и создадим константу с дефолтным значением которое подставиться в случае ошибки

        const DEFAULT_WIDTH = "800px"

        <div class="modal-window" style="width: ${options.width || DEFAULT_WIDTH}">


        Теперь обработаем closable. Вырежем весь тег с крестиком и вместо него пропишем тернарный оператор.
        Если options.closable - тру, тогда будет показан крестик если фолс тогда пустая строка ''

        ${options.closable ? `<span class="modal-close">&times;</span>` : ''}


        Проверим результат через консоль. Все работает.




Закрытие окна по клику на крестик или на подложку(оверлей).

Сделаем это наиболее простым по мнению автора способом. Так как мы знаем что есть дата аттрибуты которые можно
    прописать в тегах для добавления кастомных аттрибутов тегу. Добавим аттрибут data-close всем эл. при клике
    на которые МО будет закрываться. В данном случае это крестик и модал оверлей. Присвоим ему значение "true"
    так как когда будем проверять на попадание по эл. у него в датасете клоуз должно быть тру, а если не
    присвоим будет пустая строка, что превратится в фолс, если при этом кликать на эл. который не содержит 
    аттрибут data-close то значение будет андефайнед.

    <div class="modal-overlay" data-close="true">

    ${options.closable ? `<span data-close="true" class="modal-close">&times;</span>` : ''}


    Навесим обработчик на весь элемент $modal в modal.js, а в ф-ю пропишем консольлог для просмотра по какому
    евент таргету клацаем есть ли у него в dataset(содержит все аттрибуты data у данного эл.) ключ close.
    Если нету - андефайнед, если есть - будет строка которую мы присвоили в data-close(в принципе не важно что
    за строка лишь бы не пустая)
    
    $modal.addEventListener('click', event => {
        console.log('Clicked', event.target.dataset.close)
    })

    То есть теперь можно прописать условие если event.target.dataset.close - тру, то вызвать метод close.
    Но этот метод идет позже по коду, как его вызвать, не дублировать же код. Возвращая методы опен и клоуз
    мы по сути возвращаем объект, поэтому ничего нам не мешает создать объект заранее(выше обработчика события)
    и перенести методы туда, а вернуть просто переменную с объектом, а в обработчике события добавить метод
    закрытия modal.close(); который теперь будет работать.

        const $modal = _createModal(options);
        const ANIMATION_SPEED = 200;
        let closing = false;

        const modal = {
            open(){
                !closing && $modal.classList.add('open'); 
            },
            close() {
                closing = true;
                $modal.classList.remove('open'); 
                $modal.classList.add('hidding'); 
                setTimeout(() =>{
                    $modal.classList.remove('hidding'); 
                    closing = false;
                }, ANIMATION_SPEED);
            },
            destroy() {}
        }

        $modal.addEventListener('click', event => {
            console.log('Clicked', event.target.dataset.close);
            if(event.target.dataset.close){
                modal.close();
            }
        })

        return modal
    }

    Теперь при клике на крестик или подложку МО закрывается.



Теперь создадим метод destroy() {} и перенесем его в ретёрн как часть возвращаемого объекта.
    В этом методе нам нужно будет убрать часть ДОМ дерева и очистить обработчик события, также дестрой
    должен быть ПУБЛИЧНЫМ(быть приписа к данному ВОЗВРАЩАЕМОМУ объекту const modal) - переносим его в 
    ретёрн потому что в дальнейшем так с ним проще будет работать. Реализуем это методом Object.assign
    к которому добавим метод дестрой, таким образом расширив его.

        return Object.assign(modal, {
            
        })


    Для того что бы убрать модальное окно из ДОМ дерева, обратимся к самой ноде $modal, потом к его
        родительской ноде parentNode и у нее вызываем метод removeChild указывая что нужно удалить
        само МО $modal.

        $modal.parentNode.removeChild($modal);


    Добавим дополнительную защиту через переменную let destroyed = false; 

        let closing = false;
        let destroyed = false;


    Теперь в метод дестрой пропишем destroyed = true; это нужно для того что бы после удаления ноды,
        можно было снова ее показать методом open, сейчас это не работает потому что мы показывали
        просто единожды созданное окно методом добавления класса видимости, а теперь класс добавить
        не к чему потому что верстка модалки не генерируется заново. В случае более комплексной
        логики это может вызывать проблеммы, поэтому нужно добавить условием в const modal что 
        если destroyed = тру, тогда мы не запускаем метод open, пока пропишем туда консольлог с
        выводом сообщения о статусе дестроед.

         open(){
            if(destroyed){
                console.log('Modal is destroyed')
            }
            !closing && $modal.classList.add('open'); 
        },


    Очистим обработчик события, так как он будет вызывать утечку памяти. Так как мы сейчас работаем в 
        замыкании, то мы можем создать переменную слушателя и в нее вырезать логику которая у нас была
        в обработчике события, при этом уберем консоль лог который нам больше не нужен. А в обработчик
        события теперь просто добавим ссылку на эту переменную. 

        const listener = event => {
            if(event.target.dataset.close){
                modal.close();
            }
        }

        $modal.addEventListener('click', listener)


    Это мы сделали чтобы у нас была ф-я которую в последствии можно удалить из нашей корневой ноды при
        помощи метода removeEventListener. Теперь мы точно знаем что у нас не будет утечек памяти если
        мы уничтожаем модальное окно.

        return Object.assign(modal, {
        destroy() {
            $modal.parentNode.removeChild($modal);
            $modal.removeEventListener('click', listener);
            destroyed = true;
        }



Добавим метод setContent для динамеческого формирования контента. Он тоже будет публичным, поэтому
    нам нужно его присовокупить к возвращаемому из этой ф-и объекту, можно прописать его в модал,
    а можно к дестрой. Пропишем его к дестрой через запятую. В качестве параметра он будет принимать
    некий html.

                destroyed = true;
            },
            setContent(html) {

            }

    Теперь нам нужно динамически поместить этот html в нужное место, а именно в див с классом модал-бади
        можно это сделать по классу, а можно добавить дата аттрибут data-content, что будет более правильно
        чтобы не мешать логику и визуализацию. Теперь в методе сетКонтент обратимся к ноде  $modal и в ней
        найдем элемент с аттрибутом дата-контент querySelector('[data-content]') и его внутренний хтмл
        заменим на тот который приходит в параметры .innerHTML = html;

        setContent(html) {
            $modal.querySelector('[data-content]').innerHTML = html;
        }

        Протестируем в консоли, сначала вызовем окно методом open() , а потом setContent('test') и этот метод
        динамически заменил содержимое элемента.




Займемся динамическим формированием футера. В index.js допишем свойство объекта const modal = $.modal({ с названием
    footerButtons, это будет массив с объектами, где каждый объект будет описывать кнопку. text: 'Ok' - надпись на
    кнопке, type: 'primary' - указан стиль бутстрапа(у автора он подключен), можно указать свои стили, handler() -
    это метод с кодом который будет выполнятся при нажатии на кнопку, пока впишем консольлог.

        footerButtons:[
            {text: 'Ok', type: 'primary', handler(){
                console.log("Primary clicked")
            }},
            {text: 'Cancel', type: 'danger', handler(){
                console.log("Danger clicked")
            }}
        ]


    На основе этого массива теперь будет строиться футер, а если массива нету, тогда футер не показывать.
        Эти опции передаются в  _createModal и по сути нужно в нем сделать верстку в футере. Но теперь задача
        сложнее потому что для каждой кнопки нужно назначить свой обработчик события. 
        
        Удаляем верстку вместе с дивом <div class="modal-footer">. Для формирования футера создадим еще одну
        приватную ф-ю function _createModalFooter в которую будет приходить массив buttons и ему зададим 
        значение по умолчанию - пустой массив []. Для добавления обр. соб. каждой кнопке нам нужно работать
        не со строками а с нодами в хтмл.


    Для начала напишем проверку на пустой массив. Если длинна массива баттонс будет равна 0 тогда мы
        создаем пустой эл. див. (можно оптимизировать чтобы совсем ничего не добавлять, но мы оставим так).

            if(buttons.length === 0) {
                return document.createElement('div')
            }


    Создаем обертку для кнопок тега див и присваивания ему класса modal-footer. Также пропишем
        что будем по итогу эту обертку возвращать из ф-и return wrap (пока только шаблон).

        const wrap = document.createElement('div');
        wrap.classList.add('modal-footer');

        return wrap


        Для добавления этой обертки в нужное место в методе создания всего МО  _createModal создадим переменную
        в которую будем получать созданную обертку из ф-ии _createModalFooter вместе с переданными параметрами

        const footer = _createModalFooter(options.footerButtons);


        Следующим шагом нужно эту обертку прикрепить в нужное место после блока модал-бади, но в чистом JS
        такой возможности нету, поэтому мы сделаем свою ф-ю которая будет этим заниматься. Но вместо ф-и
        мы попрактикуем работу с прототипами - в конечном итоге все эти элементы это класс Element. У него 
        мы можем обратиться к прототипу и создать допольнительный метод appendAfter  который будет ф-й и 
        она будет принимать в себя какой-то элемент, и позже у определенной ноды мы будем вызывать этот
        метод appendAfter и говорить после какого элемента вставить нужное содержимое. 
        
        Саму ф-ю appendAfter автор загуглил ( append element after another javascript )  и нашел реализацию
        на стековерфлоу которая у него заработала:
        element.parentNode.insertBefore(newElement, element.nextSibling); -   
        так что это все не нужно помнить, а можно нагуглить и подстроить под свой макет. Подстраиваем - 
        обращаемся к элементу который передаем element к его parentNode и говорим что нам нужно сделать
        (выполнить) метод insertBefore элемент this - в данном случае будет футером.

        Element.prototype.appendAfter = function(element) {
            element.parentNode.insertBefore(this, element.nextSibling);
        }


        Теперь после создания футера его можно вставить нашим методом appendAfter после элемента модал-бади
        который мы найдем по дата селектору дата-контент, таким образом мы вставим футер в нужное место верстки.

        const footer = _createModalFooter(options.footerButtons);
        footer.appendAfter(modal.querySelector('[data-content]'));

        Проверим в консоли - создадим окно и видим что футер присутствует в нужном месте, после модал-body. А
        если обновим массив и уберем     footerButtons: - видно что теперь футер не строится.

    
        Реализуем построения динамически кнопок в футере. У нас есть массив этих кнопок buttons, пробежимся по
        нему forEach, на каждой итерации принимаем btn - это один из объектов массива. Создаем кнопку через
        createElement('button'); и присваиваем ее const $btn.  $btn.textContent берем из объекта из его свойства
        текст btn.text; Добавляем классы для кнопки чтобы ее стилизовать $btn.classList.add('btn'); - это
        базовый класс бутстрапа для кнопки.  $btn.classList.add(`btn-${btn.type || 'secondary'}`); -этот класс
        мы берем из объекта, он тоже указывается для бутстрапа, если такого свойства нету в массиве тогда
        по умолчанию будет указан стиль 'secondary'. Так как мы создаем кнопку как ноду через 
        document.createElement('button'); то теперь можем присвоить индивидуальный обр. соб. который находится 
        в handler, но если его там нету, тогда будет ссылка на ф-ю noop. Эту ф-ю мы создаем выше ф-и 
        _createModalFooter и она просто пустая(ничего не делает) - function noop() {}. Теперь помещаем созданную
        кнопку в обертку wrap.appendChild($btn)
        
        buttons.forEach(btn => {
            const $btn = document.createElement('button');
            $btn.textContent = btn.text;
            $btn.classList.add('btn');
            $btn.classList.add(`btn-${btn.type || 'secondary'}`);
            $btn.onclick = btn.handler || noop;

            wrap.appendChild($btn)
        })

        Проверяем в консоли - теперь при открытии окна у нас есть 2 кнопки, без стилей, потому что бутстрап
        у меня не подключен. И когда мы кликаем по кнопке то выдается в консоль сообщение соответвенно
        хендлеру кнопки.

    
    Сделаем что бы при клике на кнопки МО закрывалось. Для этого метод close() пропишем в хендлер к кнопкам
        в index.js

        footerButtons:[
            {text: 'Ok', type: 'primary', handler(){
                console.log("Primary clicked");
                modal.close();
            }},
            {text: 'Cancel', type: 'danger', handler(){
                console.log("Danger clicked");
                modal.close();
            }}
        ]

    Наше приложение МО готово.




+++ Динамически формируем контент окна.

В файле index.js у автора находится массив fruits заранее добавленный. Картинки я добавил свои.
        
    const fruits = [
        {id:1, title: 'Яблоки', price: 20, img:'./img/goods/female/t-shirt_blue.jpg'}, 
        {id:2, title: 'Апельсины', price: 30, img:'./img/goods/female/t-shirt_yellow.jpg'}, 
        {id:3, title: 'Манго', price: 40, img:'./img/goods/female/t-shirt_pink.jpg'}
    ];


Переходим на сайт бутстрапа и накидываем
    верстку, чтобы применить наше МО на реальном сайте. Там он копирует верстку карточки. В index.html создает
    div class="row" в нем div class="col" и в середину col вставляет верстку карточки, и таких карточек будет
    3 штуки как и колличества объектов в массиве fruits. У карточки есть картинка - копирует картинку из массива,
    прописывает тайт - яблоки. Открываем файл и видим огромную карточку на весь экран, добавим для нее стили
    прямо в верстке, это не важно потому что мы концентрируемся сейчас на JS коде - style="height: 300px;"
    Также изменяет и две остальные карточки, добавляет им каждой путь к картинке и свой тайтл. Добавляет кнопку
    и и меняет ей класс на danger.
    

        <div class="row" id="fruits">
            <div class="col">
                <div class="card">
                    <img class="carf-img-top" style="height: 300px;" src="..." alt="">
                    <div class="card-body">
                        <h5 class="card-title">Яблоки</h5>
                        <a href="#" class="btn btn-primary">Посмотреть цену</a>
                        <a href="#" class="btn btn-danger">Удалить</a>
                    </div>
                </div>
            </div>
        </div>


Так как сейчас эти карточки у нас в верстке, мы сделаем чтобы они динамически формировались на сайте на 
    основе объектов из массива fruits. Для этого в index.js создадим ф-ю render которая будет рендерить
    наш список. Он не будет принимать никаких опций, а будет работать конкретно с массивом fruits.
    Добавим в верстку id="fruits" к элементу в который будет происходить рендер <div class="row" id="fruits">.
    В ф-ии рендер обращаемся к этому элементу через квери селектор и говорим что его innerHTML будет
    равен html который мы сформируем на основе массива fruits. Если посмотреть на верстку то можно
    увидеть что структура карточек одинаковая, только меняются некоторые данные. Мы вырезаем из верстки
    структуру одной карточки, а остальные удаляем оставляя только <div class="row" id="fruits">.

    Теперь у нас есть шаблон, но чтобы его обработать создадим переменную toHTML которая будет принимать 
    параметр fruit и возвращать строку в которой будет храниться шаблон будущей карточки. Объект fruit
     - это каждый  элемент массива.

    const toHTML = fruit => `
        <div class="col">
        <div class="card">
            <img class="carf-img-top" style="height: 300px;" src="${fruit.img}" alt="${fruit.title}">
            <div class="card-body">
                <h5 class="card-title">${fruit.title}</h5>
                <a href="#" class="btn btn-primary">Посмотреть цену</a>
                <a href="#" class="btn btn-danger">Удалить</a>
            </div>
        </div>
    </div>
    `;